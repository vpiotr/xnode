//----------------------------------------------------------------------------------
// Name:        xnode_type_test.cpp
// Purpose:     Comprehensive type tests for xnode library
// Author:      Generated by GitHub Copilot
// Created:     May 2, 2025
// License:     BSD
//----------------------------------------------------------------------------------

#include "xnode.h"
#include <iostream>
#include "cunit.h"
#include <limits>
#include <cmath>

using namespace std;

// Test functions for each supported data type
void TestBoolType() {
    // Test scenario 1
    xnode node;
    bool testValue = true;
    node.set_as<bool>(testValue);
    
    AssertTrue(node.is<bool>(), "is<bool>() should return true");
    AssertTrue(node.get_as<bool>() == testValue, "get_as<bool>() should return the test value");
    
    // Test with false value
    bool testValueFalse = false;
    node.set_as<bool>(testValueFalse);
    
    AssertTrue(node.is<bool>(), "is<bool>() should return true after setting false");
    AssertTrue(node.get_as<bool>() == testValueFalse, "get_as<bool>() should return false");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<bool>(), "is<bool>() should return true for constructed node");
    AssertTrue(constructedNode.get_as<bool>() == testValue, "get_as<bool>() should return test value for constructed node");
}

void TestFloatType() {
    // Test scenario 1
    xnode node;
    float testValue = 3.14159f;
    node.set_as<float>(testValue);
    
    AssertTrue(node.is<float>(), "is<float>() should return true");
    
    // Use approximately equal for floating point comparison
    float epsilon = 0.00001f;
    float retrievedValue = node.get_as<float>();
    AssertTrue(std::abs(retrievedValue - testValue) < epsilon, 
        "get_as<float>() should return approximately the test value");
    
    // Test with negative value
    float testNegValue = -2.71828f;
    node.set_as<float>(testNegValue);
    
    AssertTrue(node.is<float>(), "is<float>() should return true for negative value");
    retrievedValue = node.get_as<float>();
    AssertTrue(std::abs(retrievedValue - testNegValue) < epsilon, 
        "get_as<float>() should return approximately the negative test value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<float>(), "is<float>() should return true for constructed node");
    retrievedValue = constructedNode.get_as<float>();
    AssertTrue(std::abs(retrievedValue - testValue) < epsilon, 
        "get_as<float>() should return approximately the test value for constructed node");
}

void TestDoubleType() {
    // Test scenario 1
    xnode node;
    double testValue = 2.7182818284590452353602874;
    node.set_as<double>(testValue);
    
    AssertTrue(node.is<double>(), "is<double>() should return true");
    
    // Use approximately equal for floating point comparison
    double epsilon = 0.0000000000001;
    double retrievedValue = node.get_as<double>();
    AssertTrue(std::abs(retrievedValue - testValue) < epsilon, 
        "get_as<double>() should return approximately the test value");
    
    // Test with negative value
    double testNegValue = -3.141592653589793238462643;
    node.set_as<double>(testNegValue);
    
    AssertTrue(node.is<double>(), "is<double>() should return true for negative value");
    retrievedValue = node.get_as<double>();
    AssertTrue(std::abs(retrievedValue - testNegValue) < epsilon, 
        "get_as<double>() should return approximately the negative test value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<double>(), "is<double>() should return true for constructed node");
    retrievedValue = constructedNode.get_as<double>();
    AssertTrue(std::abs(retrievedValue - testValue) < epsilon, 
        "get_as<double>() should return approximately the test value for constructed node");
}

void TestStringType() {
    // Test scenario 1
    xnode node;
    std::string testValue = "Hello, xnode!";
    node.set_as<std::string>(testValue);
    
    AssertTrue(node.is<std::string>(), "is<std::string>() should return true");
    AssertEquals(testValue, node.get_as<std::string>(), "get_as<std::string>() should return the test value");
    
    // Test with empty string
    std::string emptyString = "";
    node.set_as<std::string>(emptyString);
    
    AssertTrue(node.is<std::string>(), "is<std::string>() should return true for empty string");
    AssertEquals(emptyString, node.get_as<std::string>(), "get_as<std::string>() should return empty string");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<std::string>(), "is<std::string>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<std::string>(), 
        "get_as<std::string>() should return test value for constructed node");
    
    // Test with string literal
    xnode literalNode = xnode::value_of("String literal");
    AssertTrue(literalNode.is<std::string>(), "is<std::string>() should return true for string literal");
    AssertEquals(std::string("String literal"), literalNode.get_as<std::string>(), 
        "get_as<std::string>() should return the string literal");
}

void TestCharType() {
    // Test scenario 1
    xnode node;
    char testValue = 'A';
    node.set_as<char>(testValue);
    
    AssertTrue(node.is<char>(), "is<char>() should return true");
    AssertEquals(testValue, node.get_as<char>(), "get_as<char>() should return the test value");
    
    // Test with special character
    char specialChar = '\n';
    node.set_as<char>(specialChar);
    
    AssertTrue(node.is<char>(), "is<char>() should return true for special character");
    AssertEquals(specialChar, node.get_as<char>(), "get_as<char>() should return the special character");
    
    // Test with numeric character
    char numericChar = '9';
    node.set_as<char>(numericChar);
    
    AssertTrue(node.is<char>(), "is<char>() should return true for numeric character");
    AssertEquals(numericChar, node.get_as<char>(), "get_as<char>() should return the numeric character");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<char>(), "is<char>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<char>(), 
        "get_as<char>() should return test value for constructed node");
}

void TestShortType() {
    // Test scenario 1
    xnode node;
    short testValue = 12345;
    node.set_as<short>(testValue);
    
    AssertTrue(node.is<short>(), "is<short>() should return true");
    AssertEquals(testValue, node.get_as<short>(), "get_as<short>() should return the test value");
    
    // Test with negative value
    short negValue = -12345;
    node.set_as<short>(negValue);
    
    AssertTrue(node.is<short>(), "is<short>() should return true for negative value");
    AssertEquals(negValue, node.get_as<short>(), "get_as<short>() should return the negative value");
    
    // Test with max value
    short maxValue = std::numeric_limits<short>::max();
    node.set_as<short>(maxValue);
    
    AssertTrue(node.is<short>(), "is<short>() should return true for max value");
    AssertEquals(maxValue, node.get_as<short>(), "get_as<short>() should return the max value");
    
    // Test with min value
    short minValue = std::numeric_limits<short>::min();
    node.set_as<short>(minValue);
    
    AssertTrue(node.is<short>(), "is<short>() should return true for min value");
    AssertEquals(minValue, node.get_as<short>(), "get_as<short>() should return the min value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<short>(), "is<short>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<short>(), 
        "get_as<short>() should return test value for constructed node");
}

void TestIntType() {
    // Test scenario 1
    xnode node;
    int testValue = 123456789;
    node.set_as<int>(testValue);
    
    AssertTrue(node.is<int>(), "is<int>() should return true");
    AssertEquals(testValue, node.get_as<int>(), "get_as<int>() should return the test value");
    
    // Test with negative value
    int negValue = -987654321;
    node.set_as<int>(negValue);
    
    AssertTrue(node.is<int>(), "is<int>() should return true for negative value");
    AssertEquals(negValue, node.get_as<int>(), "get_as<int>() should return the negative value");
    
    // Test with max value
    int maxValue = std::numeric_limits<int>::max();
    node.set_as<int>(maxValue);
    
    AssertTrue(node.is<int>(), "is<int>() should return true for max value");
    AssertEquals(maxValue, node.get_as<int>(), "get_as<int>() should return the max value");
    
    // Test with min value
    int minValue = std::numeric_limits<int>::min();
    node.set_as<int>(minValue);
    
    AssertTrue(node.is<int>(), "is<int>() should return true for min value");
    AssertEquals(minValue, node.get_as<int>(), "get_as<int>() should return the min value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<int>(), "is<int>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<int>(), 
        "get_as<int>() should return test value for constructed node");
}

void TestLongType() {
    // Test scenario 1
    xnode node;
    long testValue = 1234567890L;
    node.set_as<long>(testValue);
    
    AssertTrue(node.is<long>(), "is<long>() should return true");
    AssertEquals(testValue, node.get_as<long>(), "get_as<long>() should return the test value");
    
    // Test with negative value
    long negValue = -9876543210L;
    node.set_as<long>(negValue);
    
    AssertTrue(node.is<long>(), "is<long>() should return true for negative value");
    AssertEquals(negValue, node.get_as<long>(), "get_as<long>() should return the negative value");
    
    // Test with max value
    long maxValue = std::numeric_limits<long>::max();
    node.set_as<long>(maxValue);
    
    AssertTrue(node.is<long>(), "is<long>() should return true for max value");
    AssertEquals(maxValue, node.get_as<long>(), "get_as<long>() should return the max value");
    
    // Test with min value
    long minValue = std::numeric_limits<long>::min();
    node.set_as<long>(minValue);
    
    AssertTrue(node.is<long>(), "is<long>() should return true for min value");
    AssertEquals(minValue, node.get_as<long>(), "get_as<long>() should return the min value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<long>(), "is<long>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<long>(), 
        "get_as<long>() should return test value for constructed node");
}

void TestLongLongType() {
    // Test scenario 1
    xnode node;
    long long testValue = 1234567890123456789LL;
    node.set_as<long long>(testValue);
    
    AssertTrue(node.is<long long>(), "is<long long>() should return true");
    AssertEquals(testValue, node.get_as<long long>(), "get_as<long long>() should return the test value");
    
    // Test with negative value
    long long negValue = -9876543210987654321LL;
    node.set_as<long long>(negValue);
    
    AssertTrue(node.is<long long>(), "is<long long>() should return true for negative value");
    AssertEquals(negValue, node.get_as<long long>(), "get_as<long long>() should return the negative value");
    
    // Test with max value
    long long maxValue = std::numeric_limits<long long>::max();
    node.set_as<long long>(maxValue);
    
    AssertTrue(node.is<long long>(), "is<long long>() should return true for max value");
    AssertEquals(maxValue, node.get_as<long long>(), "get_as<long long>() should return the max value");
    
    // Test with min value
    long long minValue = std::numeric_limits<long long>::min();
    node.set_as<long long>(minValue);
    
    AssertTrue(node.is<long long>(), "is<long long>() should return true for min value");
    AssertEquals(minValue, node.get_as<long long>(), "get_as<long long>() should return the min value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<long long>(), "is<long long>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<long long>(), 
        "get_as<long long>() should return test value for constructed node");
}

void TestUnsignedCharType() {
    // Test scenario 1
    xnode node;
    unsigned char testValue = 200;
    node.set_as<unsigned char>(testValue);
    
    AssertTrue(node.is<unsigned char>(), "is<unsigned char>() should return true");
    AssertEquals(testValue, node.get_as<unsigned char>(), "get_as<unsigned char>() should return the test value");
    
    // Test with max value
    unsigned char maxValue = std::numeric_limits<unsigned char>::max();
    node.set_as<unsigned char>(maxValue);
    
    AssertTrue(node.is<unsigned char>(), "is<unsigned char>() should return true for max value");
    AssertEquals(maxValue, node.get_as<unsigned char>(), "get_as<unsigned char>() should return the max value");
    
    // Test with min value (0)
    unsigned char minValue = std::numeric_limits<unsigned char>::min();
    node.set_as<unsigned char>(minValue);
    
    AssertTrue(node.is<unsigned char>(), "is<unsigned char>() should return true for min value");
    AssertEquals(minValue, node.get_as<unsigned char>(), "get_as<unsigned char>() should return the min value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<unsigned char>(), "is<unsigned char>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<unsigned char>(), 
        "get_as<unsigned char>() should return test value for constructed node");
}

void TestUnsignedShortType() {
    // Test scenario 1
    xnode node;
    unsigned short testValue = 12345;
    node.set_as<unsigned short>(testValue);
    
    AssertTrue(node.is<unsigned short>(), "is<unsigned short>() should return true");
    AssertEquals(testValue, node.get_as<unsigned short>(), "get_as<unsigned short>() should return the test value");
    
    // Test with max value
    unsigned short maxValue = std::numeric_limits<unsigned short>::max();
    node.set_as<unsigned short>(maxValue);
    
    AssertTrue(node.is<unsigned short>(), "is<unsigned short>() should return true for max value");
    AssertEquals(maxValue, node.get_as<unsigned short>(), "get_as<unsigned short>() should return the max value");
    
    // Test with min value (0)
    unsigned short minValue = std::numeric_limits<unsigned short>::min();
    node.set_as<unsigned short>(minValue);
    
    AssertTrue(node.is<unsigned short>(), "is<unsigned short>() should return true for min value");
    AssertEquals(minValue, node.get_as<unsigned short>(), "get_as<unsigned short>() should return the min value");
    
    // Test with higher values beyond signed short
    unsigned short highValue = 60000;
    node.set_as<unsigned short>(highValue);
    
    AssertTrue(node.is<unsigned short>(), "is<unsigned short>() should return true for high value");
    AssertEquals(highValue, node.get_as<unsigned short>(), "get_as<unsigned short>() should return the high value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<unsigned short>(), "is<unsigned short>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<unsigned short>(), 
        "get_as<unsigned short>() should return test value for constructed node");
}

void TestUnsignedIntType() {
    // Test scenario 1
    xnode node;
    unsigned int testValue = 4000000000U;
    node.set_as<unsigned int>(testValue);
    
    AssertTrue(node.is<unsigned int>(), "is<unsigned int>() should return true");
    AssertEquals(testValue, node.get_as<unsigned int>(), "get_as<unsigned int>() should return the test value");
    
    // Test with max value
    unsigned int maxValue = std::numeric_limits<unsigned int>::max();
    node.set_as<unsigned int>(maxValue);
    
    AssertTrue(node.is<unsigned int>(), "is<unsigned int>() should return true for max value");
    AssertEquals(maxValue, node.get_as<unsigned int>(), "get_as<unsigned int>() should return the max value");
    
    // Test with min value (0)
    unsigned int minValue = std::numeric_limits<unsigned int>::min();
    node.set_as<unsigned int>(minValue);
    
    AssertTrue(node.is<unsigned int>(), "is<unsigned int>() should return true for min value");
    AssertEquals(minValue, node.get_as<unsigned int>(), "get_as<unsigned int>() should return the min value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<unsigned int>(), "is<unsigned int>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<unsigned int>(), 
        "get_as<unsigned int>() should return test value for constructed node");
}

void TestUnsignedLongType() {
    // Test scenario 1
    xnode node;
    unsigned long testValue = 4000000000UL;
    node.set_as<unsigned long>(testValue);
    
    AssertTrue(node.is<unsigned long>(), "is<unsigned long>() should return true");
    AssertEquals(testValue, node.get_as<unsigned long>(), "get_as<unsigned long>() should return the test value");
    
    // Test with max value
    unsigned long maxValue = std::numeric_limits<unsigned long>::max();
    node.set_as<unsigned long>(maxValue);
    
    AssertTrue(node.is<unsigned long>(), "is<unsigned long>() should return true for max value");
    AssertEquals(maxValue, node.get_as<unsigned long>(), "get_as<unsigned long>() should return the max value");
    
    // Test with min value (0)
    unsigned long minValue = std::numeric_limits<unsigned long>::min();
    node.set_as<unsigned long>(minValue);
    
    AssertTrue(node.is<unsigned long>(), "is<unsigned long>() should return true for min value");
    AssertEquals(minValue, node.get_as<unsigned long>(), "get_as<unsigned long>() should return the min value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<unsigned long>(), "is<unsigned long>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<unsigned long>(), 
        "get_as<unsigned long>() should return test value for constructed node");
}

void TestUnsignedLongLongType() {
    // Test scenario 1
    xnode node;
    unsigned long long testValue = 18000000000000000000ULL;
    node.set_as<unsigned long long>(testValue);
    
    AssertTrue(node.is<unsigned long long>(), "is<unsigned long long>() should return true");
    AssertEquals(testValue, node.get_as<unsigned long long>(), "get_as<unsigned long long>() should return the test value");
    
    // Test with max value
    unsigned long long maxValue = std::numeric_limits<unsigned long long>::max();
    node.set_as<unsigned long long>(maxValue);
    
    AssertTrue(node.is<unsigned long long>(), "is<unsigned long long>() should return true for max value");
    AssertEquals(maxValue, node.get_as<unsigned long long>(), "get_as<unsigned long long>() should return the max value");
    
    // Test with min value (0)
    unsigned long long minValue = std::numeric_limits<unsigned long long>::min();
    node.set_as<unsigned long long>(minValue);
    
    AssertTrue(node.is<unsigned long long>(), "is<unsigned long long>() should return true for min value");
    AssertEquals(minValue, node.get_as<unsigned long long>(), "get_as<unsigned long long>() should return the min value");
    
    // Test with initialization from constructor
    xnode constructedNode = xnode::value_of(testValue);
    AssertTrue(constructedNode.is<unsigned long long>(), "is<unsigned long long>() should return true for constructed node");
    AssertEquals(testValue, constructedNode.get_as<unsigned long long>(), 
        "get_as<unsigned long long>() should return test value for constructed node");
}

void TestXNodeConstructors() {
    // Default constructor
    xnode defaultNode;
    AssertTrue(defaultNode.is_null(), "Default constructor should create null node");
    
    // value_of() constructor with different types
    xnode boolNode = xnode::value_of(true);
    AssertTrue(boolNode.is<bool>(), "value_of(bool) should create bool node");
    AssertEquals(true, boolNode.get_as<bool>(), "value_of(bool) should preserve value");
    
    xnode intNode = xnode::value_of(42);
    AssertTrue(intNode.is<int>(), "value_of(int) should create int node");
    AssertEquals(42, intNode.get_as<int>(), "value_of(int) should preserve value");
    
    xnode floatNode = xnode::value_of(3.14159f);
    AssertTrue(floatNode.is<float>(), "value_of(float) should create float node");
    float floatEpsilon = 0.00001f;
    AssertTrue(std::abs(floatNode.get_as<float>() - 3.14159f) < floatEpsilon, 
        "value_of(float) should approximately preserve value");
    
    xnode stringNode = xnode::value_of(std::string("Test String"));
    AssertTrue(stringNode.is<std::string>(), "value_of(string) should create string node");
    AssertEquals(std::string("Test String"), stringNode.get_as<string>(), 
        "value_of(string) should preserve value");
    
    // Copy constructor
    xnode copyNode(intNode);
    AssertTrue(copyNode.is<int>(), "Copy constructor should preserve type");
    AssertEquals(42, copyNode.get_as<int>(), "Copy constructor should preserve value");
    
    // Move constructor
    xnode sourceNode = xnode::value_of(123.456);
    xnode moveNode(std::move(sourceNode));
    AssertTrue(moveNode.is<double>(), "Move constructor should preserve type");
    double doubleEpsilon = 0.000001;
    AssertTrue(std::abs(moveNode.get_as<double>() - 123.456) < doubleEpsilon, 
        "Move constructor should preserve value");
    
    // Assignment operator
    xnode assignNode;
    assignNode = intNode;
    AssertTrue(assignNode.is<int>(), "Assignment operator should preserve type");
    AssertEquals(42, assignNode.get_as<int>(), "Assignment operator should preserve value");
    
    // Move assignment operator
    xnode moveAssignSource = xnode::value_of(7654ULL);
    xnode moveAssignTarget;
    moveAssignTarget = std::move(moveAssignSource);
    AssertTrue(moveAssignTarget.is<unsigned long long>(), "Move assignment should preserve type");
    AssertEquals(7654ULL, moveAssignTarget.get_as<unsigned long long>(), 
        "Move assignment should preserve value");
    
    // value_of with specified target type
    xnode convertedNode = xnode::value_of<double>(42);
    AssertTrue(convertedNode.is<double>(), "value_of<T>() should create node of specified type");
    AssertTrue(std::abs(convertedNode.get_as<double>() - 42.0) < doubleEpsilon, 
        "value_of<T>() should convert to specified type");
}

int xnode_type_test() {
    TEST_PROLOG();
    
    // Test each data type individually
    TEST_FUNC(BoolType);
    TEST_FUNC(FloatType);
    TEST_FUNC(DoubleType);
    TEST_FUNC(StringType);
    TEST_FUNC(CharType);
    TEST_FUNC(ShortType);
    TEST_FUNC(IntType);
    TEST_FUNC(LongType);
    TEST_FUNC(LongLongType);
    TEST_FUNC(UnsignedCharType);
    TEST_FUNC(UnsignedShortType);
    TEST_FUNC(UnsignedIntType);
    TEST_FUNC(UnsignedLongType);
    TEST_FUNC(UnsignedLongLongType);
    
    // Test constructors
    TEST_FUNC(XNodeConstructors);
    
    TEST_EPILOG();
}

int main() {
    return xnode_type_test();
}